kProto
======


## 1. Types
Primitives:
- `bool`
- `bytes`
- `string`
- ints: `int8`, `int16`, `int32`, `int64`
- uints: `uint8`/`byte`, `uint16`, `uint32`, `uint64`
- floats: `float32`, `float64`
- uids: `u128`, `u256`, `uuid`
- timestamp: `timestamp`, `timestamptz`

Enums:
- `enum`

Structs:
- `struct`
- `value`

Collections:
- fixed arrays: `[size]type`
- maps: `map[key, value]`
- lists: `list[element]`


### 1.1 Constants
Constants allow to specify constant values, only support bool/int/string.

```kproto
const (
	TypeUndefined = ""
	TypeUser = "user"
	TypeMachine = "machine"
)
```


### 1.2. Enums
Enums are generated as constants. Enums can be specified only with primitive values.

```kproto
enum Type string {
    undefined = ""
    user = "user"
    machine = "machine"
}

enum Type uint32 {
    undefined = 0
    user = 1
    machine = 2
}
```

### 1.3. Structs
Structs are simple field-type pairs. Each field is specified by a number. 
Fields can be added/removed/renamed, but their numbers must stay the same.
Numbers can be generated by the formatter. Numbers go in ordered sections.

```kproto
type User struct {
	id          u128        1
	name        string      2
	age         int32       3
	email       *Email      4

    // next section, numbers start at 10
    created_at  timestamp   10
    updated_at  timestamp   11
    deleted_at  timestamp   12
}

type Email struct {
	id      u128    1
	user_id u128    2
	email   string  3
}
```

### 1.4 Values
Values are immutable structs which cannot be changed later. 
Their fields automatically get their numbers.

```
type Point value {
    x int64
    y int64
}
```

### 1.5. Nullability
Everything can be specified as nullable using `*`.

```kproto
type Example struct {
	id      *u128       1
	key     *string     2
	value   *int64      3
}
```

## 2.0 Modules
- Directory is a module.
- Imports always use full path.
- Import may specify an alias as `alias "import/path"`.
- Compiler accept multiple import paths.
- Compiler import paths specify mappings between directories and (search) paths: `-I dir:path`


```kproto
module mymodule

import (
	"github.com/hello/world"
    uni "github.com/hello/universe"
)

```

## 3.0 Readers
Compiler generates type readers which wrap buffers. Readers are passed by value as slices in Go.
Readers are lazy and do not read anything until required.

```kproto
type Block struct {
    id      BlockID     1
    head    BlockHead   2
    body    BlockBody   3
}

type BlockID value {
    index   int64
    hash    u256
}

type BlockHead struct {
    type        BlockType   1
    index       int64       2
    parent      BlockID     3

    base        BlockID     10
    parent      *BlockID    11
}
```

```go
func readBlock(buffer kproto.Buffer) {
    // get block reader
    block := blockchain.NewBlockReader(buffer)
    id := block.ID()
    fmt.Println("Processing block: ", id)

    // read head
    head := block.Head()
    base := head.Base()
    parent := head.Parent()

    fmt.Println("Block base: ", base)
    fmt.Println("Block parent: ", parent)

    // read body
    body := block.Body()
    readBody(body)
}
```

## 4.0 Writers
Compiler generates type writers which wrap buffers. Writers are passed by value as slices in Go.
Internally, write buffers hold a table buffer and a data buffer.

```go
func writeBlock(prev blockchain.Block, buffer kproto.WriteBuffer) ([]byte, error) {
    // get block writer
    block := blockchain.NewBlockWriter(buffer)
    block.ID(id)

    // write head
    head := block.Head()
    head.Index(index)
    head.Type(type)
    head.Base(base)
    head.Parent(parent)
    head.End()

    // write body
    body := block.Body()
    body.Test(bytes)
    body.End()

    // or write body bytes
    block.BodyBytes(bodyBytes)

    // done
    block.End()
    return buffer.Bytes()
}
```

---

Â© 2021 Ivan Korobkov
